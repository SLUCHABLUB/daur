use crate::app::Action;
use crate::ui::{Length, Offset, Point, Rectangle, Size};
use crate::widget::heterogeneous::tuple::Tuple;
use crate::widget::{Direction, HasSize, Widget};
use crossterm::event::MouseButton;
use itertools::Itertools as _;
use ratatui::buffer::Buffer;
use ratatui::layout::{Constraint, Flex, Spacing};

/// A stack of two widgets
pub type TwoStack<A, B> = Stack<(A, B)>;
/// A stack of three widgets
pub type ThreeStack<A, B, C> = Stack<(A, B, C)>;
/// A stack of four widgets
pub type FourStack<A, B, C, D> = Stack<(A, B, C, D)>;

/// A heterogeneous stack of widgets
#[derive(Clone, Eq, PartialEq, Debug)]
pub struct Stack<Children: Tuple> {
    direction: Direction,
    children: Children,
    // None means that the children should be sized equally
    constraints: Option<Children::EquisizedCopyArray<Constraint>>,
    flex: Flex,
    spacing: Spacing,
}

impl<Children: Tuple> Stack<Children> {
    /// Sets the flex of elements
    #[must_use]
    pub fn flex(mut self, flex: Flex) -> Self {
        self.flex = flex;
        self
    }

    /// Sets the spacing between elements
    #[must_use]
    pub fn spacing<S: Into<Spacing>>(mut self, spacing: S) -> Self {
        self.spacing = spacing.into();
        self
    }

    fn areas(&self, area: Rectangle) -> Children::EquisizedCopyArray<Rectangle> {
        #[expect(
            clippy::unwrap_used,
            reason = "the returned iterators have the same size as the array/length argument"
        )]
        if let Some(constraints) = self.constraints {
            area.split(constraints, self.direction, self.flex, &self.spacing)
                .collect_tuple()
                .map(From::from)
                .unwrap()
        } else {
            area.split_equally(Children::LEN, self.direction)
                .collect_tuple()
                .map(From::from)
                .unwrap()
        }
    }
}

macro_rules! impl_stack {
    ($($generic:ident),*; $($index:tt),*) => {
        #[expect(clippy::allow_attributes, reason = "code is generated by a macro")]
        #[allow(dead_code, reason = "code is generated by a macro")]
        impl<$($generic),*> Stack<($($generic),*)> {
            /// Constructs a new stack
            pub fn new(
                direction: Direction,
                children: ($($generic),*),
                constraints: <($($generic),*) as Tuple>::EquisizedCopyArray<Constraint>,
            ) -> Self {
                Stack {
                    direction,
                    children,
                    constraints: Some(constraints),
                    flex: Flex::SpaceBetween,
                    spacing: Spacing::default(),
                }
            }

            /// Constructs a horizontal stack.
            pub fn horizontal(
                children: ($($generic),*),
                constraints: <($($generic),*) as Tuple>::EquisizedCopyArray::<Constraint>,
            ) -> Self {
                Self::new(Direction::Right, children, constraints)
            }

            /// Constructs a vertical stack.
            pub fn vertical(
                children: ($($generic),*),
                constraints: <($($generic),*) as Tuple>::EquisizedCopyArray::<Constraint>,
            ) -> Self {
                Self::new(Direction::Down, children, constraints)
            }

            /// Constructs a new stack where all children have a _"canonical"_ size
            pub fn new_sized(
                direction: Direction,
                children: ($($generic),*)
            ) -> Self
                where
                    $($generic: HasSize),*
            {
                let constraints = [$(
                    children.$index.size().parallel_to(direction).constraint(),
                )*];

                Self::new(direction, children, constraints)
            }

            /// Constructs a horizontal stack where all children have a _"canonical"_ size
            pub fn horizontal_sized(children: ($($generic),*)) -> Self
                where
                    $($generic: HasSize),*
            {
                Self::new_sized(
                    Direction::Right,
                    children,
                )
            }

            /// Constructs a vertical stack where all children have a _"canonical"_ size
            pub fn vertical_sized(children: ($($generic),*)) -> Self
                where
                    $($generic: HasSize),*
            {
                Self::new_sized(
                    Direction::Down,
                    children,
                )
            }

            /// Constructs a new stack with equally sized children.
            pub fn new_equisized(
                direction: Direction,
                children: ($($generic),*),
            ) -> Self {
                Stack {
                    direction,
                    children,
                    constraints: None,
                    flex: Flex::SpaceBetween,
                    spacing: Spacing::default(),
                }
            }

            /// Constructs a horizontal stack.
            pub fn equisized_horizontal(
                children: ($($generic),*),
            ) -> Self {
                Self::new_equisized(Direction::Right, children)
            }

            /// Constructs a vertical stack.
            pub fn equisized_vertical(
                children: ($($generic),*),
            ) -> Self {
                Self::new_equisized(Direction::Down, children)
            }
        }

        impl<$($generic: Widget),*> Widget for Stack<($($generic),*)> {
            fn render(&self, area: Rectangle, buf: &mut Buffer, mouse_position: Point) {
                let areas = self.areas(area);
                $(
                    self.children.$index.render(areas[$index], buf, mouse_position);
                )*
            }

            fn click(
                &self,
                area: Rectangle,
                button: MouseButton,
                position: Point,
                action_queue: &mut Vec<Action>,
            ) {
                let areas = self.areas(area);
                $(
                    if areas[$index].contains(position) {
                        self.children.$index.click(areas[$index], button, position, action_queue);
                    }
                )*
            }
        }

        impl<$($generic: HasSize),*> HasSize for Stack<($($generic),*)> {
            fn size(&self) -> Size {
                let mut parallel = Length::ZERO;
                let mut orthogonal = Length::ZERO;

                $(
                    let child = self.children.$index.size();
                    parallel += child.parallel_to(self.direction);
                    orthogonal = Length::max(orthogonal, child.orthogonal_to(self.direction));
                )*

                let space_count = <($($generic),*)>::LEN - 1;
                parallel += Offset::from(&self.spacing) * space_count;

                Size::from_parallel_orthogonal(parallel, orthogonal, self.direction)
            }
        }
    }
}

impl_stack!(A, B; 0, 1);
impl_stack!(A, B, C; 0, 1, 2);
impl_stack!(A, B, C, D; 0, 1, 2, 3);
