use crate::app::Action;
use crate::ui::{Length, Offset, Point, Rectangle, Size};
use crate::widget::{Direction, HasSize, Widget};
use crossterm::event::MouseButton;
use itertools::Itertools as _;
use ratatui::buffer::Buffer;
use ratatui::layout::{Constraint, Flex, Spacing};

/// A stack of two widgets
pub type TwoStack<A, B> = Stack<2, (A, B)>;
/// A stack of three widgets
pub type ThreeStack<A, B, C> = Stack<3, (A, B, C)>;
/// A stack of four widgets
pub type FourStack<A, B, C, D> = Stack<4, (A, B, C, D)>;

/// A heterogeneous stack of widgets
#[derive(Clone, Eq, PartialEq, Debug)]
pub struct Stack<const N: usize, Children> {
    direction: Direction,
    children: Children,
    constraints: [Constraint; N],
    flex: Flex,
    spacing: Spacing,
}

impl<const N: usize, Children> Stack<N, Children> {
    /// Sets the flex of elements
    #[must_use]
    pub fn flex(mut self, flex: Flex) -> Self {
        self.flex = flex;
        self
    }

    /// Sets the spacing between elements
    #[must_use]
    pub fn spacing<S: Into<Spacing>>(mut self, spacing: S) -> Self {
        self.spacing = spacing.into();
        self
    }

    fn areas(&self, area: Rectangle) -> [Rectangle; N] {
        #[expect(
            clippy::unwrap_used,
            reason = "the returned iterator has the same ui as the constraints one passed in"
        )]
        area.split(self.constraints, self.direction, self.flex, &self.spacing)
            .collect_array()
            .unwrap()
    }
}

macro_rules! impl_hetero {
    ($len:literal; $($generic:ident),*; $($index:tt),*) => {
        #[expect(clippy::allow_attributes, reason = "code is generated by a macro")]
        #[allow(dead_code, reason = "code is generated by a macro")]
        impl<$($generic),*> Stack<$len, ($($generic),*)> {
            /// Constructs a new stack
            pub fn new(
                direction: Direction,
                children: ($($generic),*),
                constraints: [Constraint; $len],
            ) -> Self {
                Stack {
                    direction,
                    children,
                    constraints,
                    flex: Flex::SpaceBetween,
                    spacing: Spacing::default(),
                }
            }

            /// Constructs a horizontal stack
            pub fn horizontal(
                children: ($($generic),*),
                constraints: [Constraint; $len],
            ) -> Self {
                Self::new(Direction::Right, children, constraints)
            }

            /// Constructs a vertical stack
            pub fn vertical(
                children: ($($generic),*),
                constraints: [Constraint; $len],
            ) -> Self {
                Self::new(Direction::Down, children, constraints)
            }

            /// Constructs a new stack where all children have a _"canonical"_ size
            pub fn new_sized(
                direction: Direction,
                children: ($($generic),*)
            ) -> Self
                where
                    $($generic: HasSize),*
            {
                let constraints = [$(
                    children.$index.size().parallel_to(direction).constraint(),
                )*];

                Self::new(direction, children, constraints)
            }

            /// Constructs a horizontal stack where all children have a _"canonical"_ size
            pub fn horizontal_sized(children: ($($generic),*)) -> Self
                where
                    $($generic: HasSize),*
            {
                Self::new_sized(
                    Direction::Right,
                    children,
                )
            }

            /// Constructs a vertical stack where all children have a _"canonical"_ size
            pub fn vertical_sized(children: ($($generic),*)) -> Self
                where
                    $($generic: HasSize),*
            {
                Self::new_sized(
                    Direction::Down,
                    children,
                )
            }
        }

        impl<$($generic: Widget),*> Widget for Stack<$len, ($($generic),*)> {
            fn render(&self, area: Rectangle, buf: &mut Buffer, mouse_position: Point) {
                let areas = self.areas(area);
                $(
                    self.children.$index.render(areas[$index], buf, mouse_position);
                )*
            }

            fn click(
                &self,
                area: Rectangle,
                button: MouseButton,
                position: Point,
                action_queue: &mut Vec<Action>,
            ) {
                let areas = self.areas(area);
                $(
                    if areas[$index].contains(position) {
                        self.children.$index.click(areas[$index], button, position, action_queue);
                    }
                )*
            }
        }

        impl<$($generic: HasSize),*> HasSize for Stack<$len, ($($generic),*)> {
            fn size(&self) -> Size {
                let mut parallel = Length::ZERO;
                let mut orthogonal = Length::ZERO;

                $(
                    let child = self.children.$index.size();
                    parallel += child.parallel_to(self.direction);
                    orthogonal = Length::max(orthogonal, child.orthogonal_to(self.direction));
                )*

                let space_count = $len - 1;
                parallel += Offset::from(&self.spacing) * space_count;

                Size::from_parallel_orthogonal(parallel, orthogonal, self.direction)
            }
        }
    }
}

impl_hetero!(2; A, B; 0, 1);
impl_hetero!(3; A, B, C; 0, 1, 2);
impl_hetero!(4; A, B, C, D; 0, 1, 2, 3);
